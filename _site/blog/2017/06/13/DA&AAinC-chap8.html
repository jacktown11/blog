<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/article.css">
	<link rel="stylesheet" href="/css/monokai.css">
</head>

<body>
	<div id="app">

		<!-- 文章目录 -->
		<div id="catalog-container" class="catalog-container">
			<p class="level-controller">
				展开级别：
				<button @click="modifyLevel(-1)" class="level-btn level-minus">-</button>
				<span class="level-now" v-html="expandLevel"></span>
				<button @click="modifyLevel(1)" class="level-btn level-add">+</button>
			</p>
			<blog-catalog class="catalogs" :tree-node="tree" :expand-level="expandLevel"></blog-catalog>
		</div>

		<!-- 更多文章导航 -->
		<div class="post-nav">
			<div class="home">
				<a class="home-link" href="/">返回首页</a>
			</div>
			<div class="prev no-wrap">
				上一篇：<a href="/blog/2017/06/10/DA&AAinC-chap6">数据结构与算法分析C语言描述 总结笔记 第六章</a>
			</div>
			<div class="next no-wrap">
				下一篇：<a href="/blog/2017/06/21/js-codes">javascript 代码片段</a>
			</div>
		</div>

		<!-- 文章内容区 -->
		<div class="article-wrap">
			<article id="article-container">
				<h1 id="post-title">数据结构与算法分析C语言描述 总结笔记 第八章</h1>
				<p class="meta">2017-06-13</p>
				<div class="post" ref="post">
					<h1 id="第八章-不相交集adt">第八章 不相交集ADT</h1>
<h3 id="1等价关系">1.等价关系</h3>
<ul>
  <li>自反性</li>
  <li>对称性</li>
  <li>传递性</li>
</ul>

<h3 id="2-动态等价性问题">2. 动态等价性问题</h3>
<ul>
  <li>保存每个元素所属的等价类i，等价类更新时更新每个元素的相应值，单次 Union运行时间O（N），连续N-1次运行时间大Omiga（N^2），Find时间O（1）；</li>
  <li>改进：添加关系时修改元素相对少的类中元素的等价类值，N-1次Union时间O（NlogN），任意M次Find和N-1次Union用时O（M+NlogN）。</li>
</ul>

<h3 id="3-更优方法的基本数据结构">3. 更优方法的基本数据结构</h3>
<p>构建等价类森林，它们非显式地存储在一个数组P中，P[i]值代表节点i父节点位置索引，等价类树根节点指向0（0位置不存储有效元素）：</p>

<ul>
  <li>Find:向上找到根节点位置，O（N），M次连续操作O（MN）；</li>
  <li>Union:将其中一个节点所在树根节点指向另一个节点所在树根节点，平均时间分析依赖于模型。</li>
</ul>

<h3 id="4-灵巧求并算法">4. 灵巧求并算法</h3>
<ul>
  <li>按大小求并：</li>
  <li>Find:最坏（logN），M次连续操作O（MlogN）；</li>
  <li>Union:M次连续操作平均时间O（M）。</li>
  <li>按高度求并：
对按大小求并的简单修改。</li>
</ul>

<h3 id="5-路径压缩">5. 路径压缩</h3>
<p>连续M次操作最坏O(MlogN)</p>

<h3 id="6-按秩求并和路径压缩的最坏时间">6. 按秩求并和路径压缩的最坏时间</h3>
<p>M次Find和Union操作的最坏时间O(Mlog*N),加强结论是O（Mα（M,N））,说明其几乎是线性的。</p>

				</div>
				<p>（本文完）</p>
			</article>
		</div>

	</div>

	<script src="https://cdn.bootcss.com/vue/2.5.21/vue.js"></script>
	<script src="/js/article.js"></script>
</body>

</html>
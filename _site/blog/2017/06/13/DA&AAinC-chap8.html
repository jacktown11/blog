<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title></title>
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/article.css">
	<link rel="stylesheet" href="/css/monokai.css">
	<script src="/js/article.js"></script>
</head>
<body id="body">
	<div id="mode">极简</div>
	<div id="top-nav" class="top-nav panel" class="hidden">
		<ul>
			<li>
				<a class="nav-home" href="/index.html">
					<img src="/images/base/home.png" alt="主页">
				</a>
			</li>
			<li>
				<a class="nav-posts" href="/post_list/posts.html">文章</a>
			</li>
			<li>
				<a class="nav-proj" href="/proj/proj.html">项目</a>
			</li>
			<li>
				<a class="nav-me" href="/about/intro.html">我</a>
			</li>
		</ul>
		<div id="nav-toggle" class="">
			展开目录
		</div>
	</div>
	<div id="catalog-wraper" class="">

	</div>
	<div class="wrap panel">
		<h1>数据结构与算法分析C语言描述 总结笔记 第八章</h1>
		<p class="meta">13 Jun 2017</p>
		<div class="post">
			  <h1 id="第八章-不相交集adt">第八章 不相交集ADT</h1>
<h3 id="1等价关系">1.等价关系</h3>
<ul>
  <li>自反性</li>
  <li>对称性</li>
  <li>传递性</li>
</ul>

<h3 id="2-动态等价性问题">2. 动态等价性问题</h3>
<ul>
  <li>保存每个元素所属的等价类i，等价类更新时更新每个元素的相应值，单次 Union运行时间O（N），连续N-1次运行时间大Omiga（N^2），Find时间O（1）；</li>
  <li>改进：添加关系时修改元素相对少的类中元素的等价类值，N-1次Union时间O（NlogN），任意M次Find和N-1次Union用时O（M+NlogN）。</li>
</ul>

<h3 id="3-更优方法的基本数据结构">3. 更优方法的基本数据结构</h3>
<p>构建等价类森林，它们非显式地存储在一个数组P中，P[i]值代表节点i父节点位置索引，等价类树根节点指向0（0位置不存储有效元素）：</p>

<ul>
  <li>Find:向上找到根节点位置，O（N），M次连续操作O（MN）；</li>
  <li>Union:将其中一个节点所在树根节点指向另一个节点所在树根节点，平均时间分析依赖于模型。</li>
</ul>

<h3 id="4-灵巧求并算法">4. 灵巧求并算法</h3>
<ul>
  <li>按大小求并：</li>
  <li>Find:最坏（logN），M次连续操作O（MlogN）；</li>
  <li>Union:M次连续操作平均时间O（M）。</li>
  <li>按高度求并：
对按大小求并的简单修改。</li>
</ul>

<h3 id="5-路径压缩">5. 路径压缩</h3>
<p>连续M次操作最坏O(MlogN)</p>

<h3 id="6-按秩求并和路径压缩的最坏时间">6. 按秩求并和路径压缩的最坏时间</h3>
<p>M次Find和Union操作的最坏时间O(Mlog*N),加强结论是O（Mα（M,N））,说明其几乎是线性的。</p>

			  
			<p class="to-jianshu">
				您还可以在
				<a href="https://www.jianshu.com/u/4b533d3e0184" target="_blank">我的简书</a>上找到本文并评论。
			</p>

		</div>
	</div>
</body>
</html>
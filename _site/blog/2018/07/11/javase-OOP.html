<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/article.css">
	<link rel="stylesheet" href="/css/monokai.css">
	<script src="/js/article.js"></script>
</head>
<body id="body" class="star-bg attached-bg">
	<nav id="top-nav" class="top-nav panel">
		<ul>
			<li>
				<a class="nav-home" href="/index.html">
					<img src="/images/base/home.png" alt="主页">
				</a>
			</li>
			<li>
				<a class="nav-posts" href="/pages/post_list.html">文章</a>
			</li>
			<li>
				<a class="nav-proj" href="/pages/proj.html">项目</a>
			</li>
			<li>
				<a class="nav-me" href="/pages/intro.html">我</a>
			</li>
		</ul>
	</nav>

	<div id="catalog-wraper" class="catalog-wraper hidden">

	</div>
	
	<article class="wrap panel">
		<h1>javase OOP</h1>
		<p class="meta">11 Jul 2018</p>
		<div class="post">
			  <h2 id="类与对象">类与对象</h2>
<ul>
  <li><strong>类</strong>: 用于描述多个对象的共同特征，它是对象的模板。</li>
  <li><strong>对象</strong>: 用于描述现实中的个体，它是类的实例。</li>
  <li>类的定义: 使用关键字class来定义java中的类</li>
  <li>定义类格式
    <pre><code class="language-txt">  class 类名 {
      //属性
      数据类型 变量名;
      …
      //方法
      修饰符 返回值类型 方法名(参数){   }
      …
  }
</code></pre>
  </li>
  <li>创建对象格式
    <pre><code class="language-txt">  类名 对象名 = new 类名();
</code></pre>
  </li>
</ul>

<h2 id="封装private和this关键字">封装（private和this关键字）</h2>

<h3 id="封装">封装:</h3>

<p>把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式</p>

<h3 id="封装的体现">封装的体现</h3>
<ul>
  <li>变量: 使用 private 修饰，这就是变量的封装</li>
  <li>方法: 也是一种封装，封装了多条代码</li>
  <li>类: 也是一种封装，封装了多个方法</li>
</ul>

<h3 id="private关键字">private关键字</h3>
<ul>
  <li>私有的意思,它可以用来修饰类中的成员(成员变量，成员方法)</li>
  <li>特点：private修饰的成员只能在当前类中访问，其他类中无法直接访问</li>
</ul>

<h3 id="this关键字"><code class="highlighter-rouge">this</code>关键字</h3>
<ul>
  <li><code class="highlighter-rouge">this</code>是本类对象的引用</li>
  <li><code class="highlighter-rouge">this</code>是在方法中使用的，哪个对象调用了该方法，那么，<code class="highlighter-rouge">this</code>就代表调用该方法的对象引用</li>
  <li><code class="highlighter-rouge">this</code>什么时候存在的？当创建对象的时候，<code class="highlighter-rouge">this</code>存在的</li>
  <li><code class="highlighter-rouge">this</code>的作用：用来区别同名的成员变量与局部变量（<code class="highlighter-rouge">this.成员变量</code>），例如：
    <div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="继承">继承</h2>

<p><strong>继承</strong>是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作<code class="highlighter-rouge">子类</code>，现有类被称作<code class="highlighter-rouge">父类</code>，子类会自动拥有父类所有。</p>

<h3 id="好处">好处</h3>
<ul>
  <li>提高了代表的可维护性</li>
  <li>提高了代码的复用性</li>
  <li>让类与类之间产生了继承关系，为多态提供基础</li>
</ul>

<h3 id="弊端">弊端</h3>
<p>类与类之间的耦合度过高</p>

<h3 id="特点">特点：</h3>
<ul>
  <li>java中类只能够单继承，不能多继承，可以多层继承
    <div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">Yy</span> <span class="kd">extends</span> <span class="n">Object</span> <span class="o">{}</span>
  <span class="kd">class</span> <span class="nc">Fu</span> <span class="kd">extends</span> <span class="n">Yy</span><span class="o">{}</span>
  <span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="n">Fu</span> <span class="o">{}</span>
</code></pre>
    </div>
  </li>
  <li>所有的类都直接或者间接的继承了<code class="highlighter-rouge">Object</code>类，Object类称为祖宗类。</li>
</ul>

<h3 id="注意事项">注意事项</h3>
<ol>
  <li>使用关键字<code class="highlighter-rouge">extends</code>让类与类之间产生继承关系</li>
  <li>父类私有的成员，子类不能继承，因为根本看不到</li>
  <li>不能为了继承某个功能而随意进行继承操作， 必须要符合<code class="highlighter-rouge">IS A</code>的关系
    <pre><code class="language-txt"> 苹果 IS A 水果
 男人 IS A 人
 狗   IS A 人 , 这种情况就不能继承了
</code></pre>
  </li>
</ol>

<h3 id="继承中的成员变量关系">继承中的成员变量关系：</h3>
<ul>
  <li>不同名的变量： 子类直接继承使用</li>
  <li>同名的变量： 默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用<code class="highlighter-rouge">super.成员变量</code></li>
</ul>

<h3 id="继承中的成员方法关系">继承中的成员方法关系：</h3>
<ul>
  <li>不同名的方法： 子类直接继承使用</li>
  <li>同名的方法： 默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用<code class="highlighter-rouge">super.成员方法()</code></li>
</ul>

<h3 id="super">super</h3>

<p>用来表示当前对象中包含的父类对象空间的引用</p>

<ul>
  <li>调用父类的成员变量： <code class="highlighter-rouge">super.成员变量</code></li>
  <li>调用方法的成员方法： <code class="highlighter-rouge">super.成员方法()</code></li>
</ul>

<h3 id="方法覆盖重写override">方法覆盖/重写(override)</h3>

<p>指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖/方法重写。</p>

<ul>
  <li>注意事项
    <ol>
      <li>子类的方法声明要与父类相同</li>
      <li>子类要重写方法的方法，方法的权限修饰符不能比父类的更低; 返回值类型是与父类中相同或是其子类</li>
      <li>父类私有的方法，子类不能够进行方法重写</li>
    </ol>
  </li>
  <li>对比
    <ul>
      <li><code class="highlighter-rouge">方法重载</code>(<code class="highlighter-rouge">overload</code>)：指在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)</li>
    </ul>
  </li>
</ul>

<h2 id="抽象">抽象</h2>

<h3 id="抽象方法">抽象方法</h3>

<p>方法只有声明部分，没有方法体</p>

<h3 id="抽象类">抽象类</h3>
<ul>
  <li>包含抽象方法的类，一定是抽象类</li>
  <li>使用 abstract 修饰的类，是抽象类</li>
</ul>

<h4 id="抽象类的特点">抽象类的特点</h4>
<ul>
  <li>抽象类与抽象方法都必须使用 abstract来修饰</li>
  <li>抽象类不能直接创建对象</li>
  <li>抽象类中可以有抽象方法，也可以没有抽象方法</li>
  <li>抽象类的子类
    <ul>
      <li>全部实现了父类抽象方法的具体类</li>
      <li>未实现或未完全实现父类抽象方法的抽象类</li>
    </ul>
  </li>
</ul>

<h4 id="释疑">释疑</h4>

<p>没有抽象方法的抽象类的意义是什么？</p>

<p>可以通过这种方式禁止该类被实例化。</p>

<h2 id="接口">接口</h2>

<h3 id="概述">概述</h3>

<p>理解为是一个特殊的抽象类，但它不是类，是一个接口</p>

<ul>
  <li>定义一个接口用interface关键字,<code class="highlighter-rouge">interface Inter{}</code></li>
  <li>一个类实现一个接口，使用implements关键字,<code class="highlighter-rouge">class Demo implements Inter{}</code></li>
  <li>接口不能直接创建对象，通过多态的方式，由子类来创建对象(接口多态)</li>
</ul>

<h3 id="接口中的成员特点">接口中的成员特点</h3>
<ul>
  <li>成员变量
    <ul>
      <li>只能是<code class="highlighter-rouge">final</code>修饰的常量</li>
      <li>默认修饰符： <code class="highlighter-rouge">public static final</code></li>
    </ul>
  </li>
  <li>构造方法
    <ul>
      <li>无</li>
    </ul>
  </li>
  <li>成员方法
    <ul>
      <li>只能是抽象方法</li>
      <li>默认修饰符: <code class="highlighter-rouge">public abstract</code></li>
    </ul>
  </li>
</ul>

<h3 id="类与类类与接口接口与接口之间的关系">类与类，类与接口，接口与接口之间的关系</h3>
<ul>
  <li>类与类之间：继承关系，单继承，可以是多层继承</li>
  <li>类与接口之间: 实现关系，单实现，也可以多实现</li>
  <li>接口与接口之间：继承关系，单继承，也可以是多继承</li>
  <li>Java中的类可以继承一个父类的同时，实现多个接口</li>
</ul>

<h2 id="多态">多态</h2>

<p>理解为同一种物质的多种形态</p>

<h3 id="使用的前提">使用的前提</h3>
<ul>
  <li>有继承或者实现关系</li>
  <li>要方法重写</li>
  <li>父类引用指向子类对象</li>
</ul>

<h3 id="成员访问特点">成员访问特点</h3>
<ul>
  <li>编译期看引用类型是否有该成员</li>
  <li>运行期成员属性必须是该引用类型成员，而方法则可能是被具体子类覆盖过的</li>
</ul>

<h3 id="好处-1">好处</h3>

<p>提高了程序的扩展性</p>

<h3 id="弊端-1">弊端</h3>
<p>不能访问子类的特有功能</p>

<h3 id="多态的分类">多态的分类</h3>
<ul>
  <li>(抽象)类的多态
    <div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Fu</span> <span class="o">{</span>
                  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="n">Fu</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“重写父类抽象方法”</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">//类的多态使用</span>
  <span class="n">Fu</span> <span class="n">fu</span><span class="o">=</span> <span class="k">new</span> <span class="n">Zi</span><span class="o">();</span>
</code></pre>
    </div>
  </li>
  <li>接口的多态
    <div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="kd">interface</span> <span class="nc">Fu</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">implements</span> <span class="n">Fu</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“重写接口抽象方法”</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">//接口的多态使用</span>
  <span class="n">Fu</span> <span class="n">fu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Zi</span><span class="o">();</span>
</code></pre>
    </div>
  </li>
</ul>

<h3 id="instanceof关键字">instanceof关键字</h3>
<ul>
  <li>格式： <code class="highlighter-rouge">对象名 instanceof 类名</code></li>
  <li>返回值： <code class="highlighter-rouge">true</code>/<code class="highlighter-rouge">false</code></li>
  <li>作用： 判断指定的对象是否为给定类(接口)创建的对象</li>
</ul>


			  
			<p class="to-jianshu">
				转载请注明出处，您还可以在
				<a href="https://www.jianshu.com/u/4b533d3e0184" target="_blank">我的简书</a>上找到本文并评论。
			</p>

		</div>
	</article>

	<div class="sidebar">
		<a href="#" class="to-top"></a>
		<a href="#" class="nav-ctrl" id="navCtrl">目录</a>
		<a href="#" class="mode" id="mode">极简</a>
	</div>

</body>
</html>
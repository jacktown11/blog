---
layout: article
title: java IO
categories: [java]
tags: [javase]
---

# 异常

java代码在运行时期发生的问题就是异常。在java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）

## 异常的继承体系

`java.lang`包中提供了`Throwable`类，是java中所有的错误和异常的超类，其子类`Excepiton`用以表示异常，而`Error`表示错误。

- Throwable
    * Error
    * Exception
        - RuntimeException
            * NullPointerException
            * IndexOutOfBoundsException
                - ArrayIndexOutOfBoundsException
        - ...

### 错误与异常区别

- `Exception`发生在编译、运行期间，我们可以对在运行中对异常进行具体的处理；若不处理异常，程序将会结束运行。
- `Error`更严重，出现在运行期间，错误通常没有具体的处理方式，程序将会结束运行；`Error`错误的发生往往都是系统级别的问题，都是`jvm`所在系统发生的，并反馈给`jvm`的。我们无法针对处理，只能修正代码。错误必须要修改程序让错误不发生。

## 异常的创建过程

- 运行发生异常时，`JVM`创建异常对象抛出
- `JVM`查看该异常是否在当前方法内部是否被处理
- 如果未被处理，该异常会被抛出给方法的调用者，让调用者处理，如果调用者也不处理，则一直向上抛出到`main`
- 如果直到`main`方法该异常仍旧不能被处理，那么`JVM`会输出异常信息，并停止执行程序
- 抛出的异常未被处理前，后续代码都不会被执行（即使被处理，有的代码也可能不会被执行了）

## 抛出异常

- `throw`关键字用于抛出异常对象，异常对象中含有异常的相关信息。
-  `throws`关键字在方法声明上标记该方法可能抛出异常

例如

```java
public void go() throws Exception{
    throw new Exception("一个异常");
}
```

## 异常处理
```java
try{

}catch(ExceptionType1 e1){

}catch(ExceptionType2 e2){

}finally{

}
```
`finally`即使有异常也会被执行，在`io`读取中释放资源很常用

### 多catch细节
多个`catch`匹配是，一旦匹配成功，后边的`catch`一律忽略，匹配成功的`catch`执行完毕直接执行`finally`（如果有）。因此如果两种有继承关系的异常分别放在某两个`catch`中，那么子类型应该放在前面，否则子类型永远不会执行。

## 运行时期异常的特点

`RuntimeException`，相对的编译时期异常。

方法的声明上不需要`throws`语句，调用者也不是必须要处理的。

设计原因： 运行异常是不该发生的，如果真的发生了，后面的代码不再具有意义，程序人员应该修改源代码。

## 子类重写父类方法时是异常的处理

- 父类如果有抛出异常，子类只能声明父类异常或者该异常的子类，或者不声明。
- 当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集
- 当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常
- 父类没抛出异常，但子类内部有可能出现异常时，可以通过`try-catch`处理，如果处理不了，也只能抛出运行时异常（该异常可以不声明）

## Throwable类的方法

|方法 |说明 |
|- |- |
|String `getMessage()` |返回异常信息详细描述 |
|String `toString`() |返回异常信息的简短描述 |
|void `printStackTrace`() |将异常信息追踪栈输出到到标准错误流 |

## 自定义异常
如果Java没有提供你需要的异常，则可以自定义异常类。

编译时异常继承`Exception`，运行时异常继承`RuntimeException`。

# IO概述
- 当需要把内存中的数据存储到持久化设备上这个动作称为输出（写）`Output`操作。
- 当把持久设备上的数据读取到内存中的这个动作称为输入（读）`Input`操作。
- 因此我们把这种输入和输出动作称为`IO`操作。

# File类
文件和目录路径名的抽象表示形式，该类具有平台无关性。

## 路径
- `windows`下文件（夹）名不区分大小写，`linux`下则区分。

### 绝对路径与相对路径

#### 绝对路径
在系统中具有唯一性，如`c:\\windows\\system32`、`http://www.baidu.com`

#### 相对路径
表示的是路径之间的相对关系

- 父目录，唯一
- 子目录，可以不唯一

## 静态字段
- `static String pathSeparator`，与系统有关的路径分隔符（整个目录的分割，表示整个目录结束，比如`windows`下为`;`，在`linux`下为`:`）
- `static Char separator`，与系统相关的名称分隔符（单个目录名称的分隔符，表示单个目录名称结束，比如在`windows`下为`\`，在`linux`下为`/`）

## 构造方法
构造方法本身不判断路径是否存在

|声明 |解释 |
|- |- |
|`File(String pathname)` |`pathname`表示的是文件或文件夹的路径，将其封装成`File`对象 |
|`File(String parent, String child)` |将父路径和子路径组装起来得到整个路径，并将其转为`File`对象，优点：可以单独操作父路径或子路径 |
|`File(File parent, String child)`|基于父`File`对象的路径组装子路径，并转为`File`对象，有点：父路径可以直接调用`File`的方法 |

## 创建与删除

|方法 |解释 |
|- |- |
|boolean `createNewFile`() |创建文件（路径在构造方法参数中），若已存在不再创建，返回false |
|boolean `mkdir`() |创建单层文件夹，若已存在不再创建，返回false |
|boolean `mkdirs`() |创建（可多层）文件夹，若已存在不再创建，返回false |
|boolean `delete`() |删除文件/文件夹，返回值为删除是否成功；删除的文件不进入回收站 |

## 获取功能

|方法 |解释 |
|- |- |
|String `getName`() |返回路径表示的最后的文件或者文件夹名，不考虑是否真实存在 |
|String	`getPath`() |返回路径字符串，相当于`toString()` |
|long `length()` |返回路径中表示的文件的字节数,文件夹的话总是0 |
|String `getAbsolutePath()` |返回绝对路径字符串 |
|File `getAbsoluteFile()` |返回绝对路径形式的`File`对象(即使最初的`File`使用相对路径产生的) |
|String `getParent`() |返回父路径的字符串 |
|String `getParent`() |返回父路径的`File`对象 |

## 判断功能

|方法 |解释 |
|- |- |
|boolean `exists`() |返回`File`对象封装的路径是否存在 |
|boolean `isDirectory`() |`File`对象封装的路径是不是目录 |
|boolean `isFile`() |`File`对象封装的路径是不是文件 |

## list和listFile获取功能

|方法 |解释 |
|- |- |
|String[] `list`()|获取`File`中封装的路径中的所有文件夹和文件名数组，对文件调用总是返回null |
|File[] `listFile`() |获取`File`中封装的路径中的的所有文件与目录的`File`对象 |

## 文件过滤器

使用`listFile`的重载形式

- `File[] listFile(FileFilter filter) `，返回满足指定条件的文件夹与文件数组，其中的接口`FileFilter`需要自己实现如下方法
    * `boolean accept(File file)`
- `File[] listFile(FileNameFilter nameFilter)`，返回满足指定条件的文件夹与文件数组，其中的接口`FileFilter`需要自己实现如下方法
    * `boolean accept(File dir, String name)`，其中的`dir`实际是进行文件搜索的文件夹

## 递归

方法定义中调用方法本身的现象

### 直接递归

```java
public void methodA(){
    methodA();
}
```
### 间接递归

```java
public void metohdB(){
    methodC();
}
public void methodC(){
    methodB();
}
```

### 递归注意实现

- 要有出口，否则就是死递归
- 次数不能太多，否则就内存溢出


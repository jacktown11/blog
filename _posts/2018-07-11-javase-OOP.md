---
layout: article
title: javase OOP
categories: [java]
tags: [javase, OOP]
---

## 类与对象
- **类**: 用于描述多个对象的共同特征，它是对象的模板。
- **对象**: 用于描述现实中的个体，它是类的实例。
- 类的定义: 使用关键字class来定义java中的类
- 定义类格式
    ```txt
    class 类名 {
        //属性
        数据类型 变量名;
        …
        //方法
        修饰符 返回值类型 方法名(参数){   }
        …
    }
    ```
- 创建对象格式
    ```txt
    类名 对象名 = new 类名();
    ```

## 封装（private和this关键字）

### 封装:

把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式

### 封装的体现
- 变量: 使用 private 修饰，这就是变量的封装
- 方法: 也是一种封装，封装了多条代码
- 类: 也是一种封装，封装了多个方法

### private关键字
- 私有的意思,它可以用来修饰类中的成员(成员变量，成员方法)
- 特点：private修饰的成员只能在当前类中访问，其他类中无法直接访问

### `this`关键字
- `this`是本类对象的引用
- `this`是在方法中使用的，哪个对象调用了该方法，那么，`this`就代表调用该方法的对象引用
- `this`什么时候存在的？当创建对象的时候，`this`存在的
- `this`的作用：用来区别同名的成员变量与局部变量（`this.成员变量`），例如：
    ```java
    public void setName(String name) {
        this.name = name;
    }
    ```

## 继承

**继承**是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作`子类`，现有类被称作`父类`，子类会自动拥有父类所有。

### 好处
- 提高了代表的可维护性
- 提高了代码的复用性
- 让类与类之间产生了继承关系，为多态提供基础

### 弊端
类与类之间的耦合度过高

### 特点：
- java中类只能够单继承，不能多继承，可以多层继承
    ```java
    class Yy extends Object {}
    class Fu extends Yy{}
    class Zi extends Fu {}
    ```
- 所有的类都直接或者间接的继承了`Object`类，Object类称为祖宗类。

### 注意事项
1. 使用关键字`extends`让类与类之间产生继承关系
2. 父类私有的成员，子类不能继承，因为根本看不到
3. 不能为了继承某个功能而随意进行继承操作， 必须要符合`IS A`的关系
    ```txt
	苹果 IS A 水果
	男人 IS A 人
	狗   IS A 人 , 这种情况就不能继承了
    ```

### 继承中的成员变量关系：
- 不同名的变量： 子类直接继承使用
- 同名的变量： 默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用`super.成员变量`

### 继承中的成员方法关系：
- 不同名的方法： 子类直接继承使用
- 同名的方法： 默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用`super.成员方法()`

### super

用来表示当前对象中包含的父类对象空间的引用

- 调用父类的成员变量： `super.成员变量`
- 调用方法的成员方法： `super.成员方法()`

### 方法覆盖/重写(override)

指在子父类中，出现了方法声明相同的情况，也叫做方法覆盖/方法重写。

- 注意事项
    1. 子类的方法声明要与父类相同
    2. 子类要重写方法的方法，方法的权限修饰符不能比父类的更低; 返回值类型是与父类中相同或是其子类
    3. 父类私有的方法，子类不能够进行方法重写
- 对比
    * `方法重载`(`overload`)：指在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)

## 抽象

### 抽象方法

方法只有声明部分，没有方法体

### 抽象类
- 包含抽象方法的类，一定是抽象类
- 使用 abstract 修饰的类，是抽象类

#### 抽象类的特点
- 抽象类与抽象方法都必须使用 abstract来修饰
- 抽象类不能直接创建对象
- 抽象类中可以有抽象方法，也可以没有抽象方法
- 抽象类的子类
    - 全部实现了父类抽象方法的具体类
    - 未实现或未完全实现父类抽象方法的抽象类

#### 释疑

没有抽象方法的抽象类的意义是什么？

可以通过这种方式禁止该类被实例化。

## 接口

### 概述

理解为是一个特殊的抽象类，但它不是类，是一个接口

- 定义一个接口用interface关键字,`interface Inter{}`
- 一个类实现一个接口，使用implements关键字,`class Demo implements Inter{}`
- 接口不能直接创建对象，通过多态的方式，由子类来创建对象(接口多态)

### 接口中的成员特点
- 成员变量
	* 只能是`final`修饰的常量
	* 默认修饰符： `public static final`
- 构造方法
	* 无
- 成员方法
	* 只能是抽象方法
	* 默认修饰符: `public abstract`

###	类与类，类与接口，接口与接口之间的关系
- 类与类之间：继承关系，单继承，可以是多层继承
- 类与接口之间: 实现关系，单实现，也可以多实现
- 接口与接口之间：继承关系，单继承，也可以是多继承
- Java中的类可以继承一个父类的同时，实现多个接口

## 多态

理解为同一种物质的多种形态

### 使用的前提
- 有继承或者实现关系
- 要方法重写
- 父类引用指向子类对象

### 成员访问特点
- 编译期看引用类型是否有该成员
- 运行期成员属性必须是该引用类型成员，而方法则可能是被具体子类覆盖过的

### 好处

提高了程序的扩展性

### 弊端
不能访问子类的特有功能

### 多态的分类
- (抽象)类的多态
    ```java
    abstract class Fu {
                    public abstract void method();
    }
    class Zi extends Fu {
    public void method(){
                        System.out.println(“重写父类抽象方法”);
    }
    }
    //类的多态使用
    Fu fu= new Zi();
    ```
- 接口的多态
    ```java
    interface Fu {
        public abstract void method();
    }
    class Zi implements Fu {
        public void method(){
            System.out.println(“重写接口抽象方法”);
    }
    }
    //接口的多态使用
    Fu fu = new Zi();
    ```

### instanceof关键字
- 格式： `对象名 instanceof 类名`
- 返回值： `true`/`false`
- 作用： 判断指定的对象是否为给定类(接口)创建的对象


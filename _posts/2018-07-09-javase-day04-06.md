---
layout: article
title: javase day04-06
categories: [java]
tags: [javase]
---

## day04


### 摘要
1. 流程控制语句switch
2. 数组
3. 随机点名器案例

### 01 switch语句解构
- switch语句解构
	* switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。

	* 格式如下:
		```txt
		switch(表达式){
			case 常量1 :
			要执行的语句;
			break;
			
			case 常量2 :
			要执行的语句;
			break;
			
			case 常量3 :
			要执行的语句;
			break;
			
			default:
			要执行的语句;
			break;
		}
		```
	* 执行流程:  表达式和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束
	
	* 关键字: `switch case default break`
	
	* 举例
		- 如果等于1，则输出星期一
		- 如果等于2，则输出星期二
		- 如果等于3，则输出星期三
		- 如果等于4，则输出星期四
		- 如果等于5，则输出星期五
		- 如果等于6，则输出星期六
		- 如果等于7，则输出星期天


### 02 switch语句的星期判断
- switch语句的星期判断
	* 明确需求
		- 初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期.
	* 代码实现
		```java
		public class SwitchDemo01 {
			public static void main(String[] args) {
				int week = 5;
				switch (week) {
				case 1:
					System.out.println("星期一");
					break;
				case 2:
					System.out.println("星期二");
					break;
				case 3:
					System.out.println("星期三");
					break;
				case 4:
					System.out.println("星期四");
					break;
				case 5:
					System.out.println("星期五");
					break;
				case 6:
					System.out.println("星期六");
					break;
				case 7:
					System.out.println("星期天");
					break;
				default:
					System.out.println("输入的数字不正确...");
					break;
				}
			}
		}
		```

### 03 switch语句接受的数据类型
- JDK1.0 - 1.4  数据类型接受 `byte short int char`
- JDK1.5   数据类型接受 `byte short int char enum(枚举)`
- JDK1.7   数据类型接受 `byte short int char enum(枚举) String`

### 04 case穿透

在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。

例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。

### 05 数组的概述
* 数组的需求
	- 现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成，那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦.
* 数组的概述
	- 数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。

### 06 数组的定义
- 几种定义方式
	* 方式一（静态初始化）
		```txt
		类型[] 数组名 = new 类型[长度];
		```
	* 方式二（动态初始化）
		```txt
		类型[] 数组名 = new 类型[]{元素，元素，……};
		```
	* 方式三（动态初始化）
		```txt
		类型[] 数组名 = {元素，元素，元素，……};	 
		```
- length属性
	* Java提供一个属性,操作索引的数组的一个属性,就是数组的长度, 属性的名字`length`
	* 使用属性: `数组名.length` 
	* 数据类型: `int`
- 索引
	* 所有元素自动编号,编号称作`索引（index）`
	* 数组的最小索引是0, 最大索引是`数组.length-1`
	* 可使用索引访问数组存储的元素：`数组名[索引]`
	
### 07 JVM内存划分

JVM对自己的内存划分为5个区域

- 寄存器:内存和CUP之间
- 本地方法栈: JVM调用了系统中的功能
- 方法和数据共享: 运行时期class文件进入的地方
- 方法栈:所有的方法运行的时候进入内存
- 堆:存储的是容器和对象

### 08 数组的内存过程

- `int[] x;`	// 声明一个int[]类型的变量
- `x = new int[100];`	// 创建一个长度为100的数组

- 第一行代码`int[] x;`声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值
- 第二行代码`x = new int[100];`创建了一个数组创建过程中会在堆内存中自动分配可以存储100个int的内存空间，并存入对应默认值，然后将数组的地址赋值给变量x，这样在程序运行期间可以使用变量x来引用数组。

### 09 为数组的元素赋值
- 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。
- 赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值

### 10 遍历数组
- 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历
- 遍历方法：常用的一种方式是采用for循环，用索引遍历从0递增到`length-1`逐个访问各个数组元素
	
### 11 数组中常见的异常

1. 数组的索引越界异常
2. 空指针异常

```java
public class ArrayDemo_4{
	public static void main(String[] args){
		//数组的索引越界异常
		//int[] arr = {5,2,1};
		//数组中3个元素,索引 0,1,2
		//System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3
		
		//空指针异常
		int[] arr2 = {1,5,8};
		System.out.println(arr2[2]);
		arr2 = null; // arr2 不在保存数组的地址了
		System.out.println(arr2[2]);//java.lang.NullPointerException
	}
}
```

### 12 数组最值
- 数组获取最值的原理思想
	* 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素
- 代码实现
	```java
	public class ArrayDemo05 {
		public static void main(String[] args) {
			int[] arr = { 4, 1, 6, 3, 9, 8 }; 	// 定义一个数组
			int max = arr[0]; 					// 定义变量max用于记住最大数，首先假设第一个元素为最大值
			// 下面通过一个for循环遍历数组中的元素
			for (int x = 1; x < arr.length; x++) {
				if (arr[x] > max) { 			// 比较 arr[x]的值是否大于max
					max = arr[x]; 				// 条件成立，将arr[x]的值赋给max
				}
			}
			System.out.println("max=" + max); 	// 打印最大值
		}
	}
	```

### 13 二维数组的定义
- 二维数组的作用
	* 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？
	* 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。
- 定义格式
	* 第一种定义格式
		* `int[][] arr = new int[3][4];`
		* 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组
	* 第二种定义格式(不推荐)
		* `int[][] arr = new int[3][];`
		* 第二种方式和第一种类似，只是数组中每个元素的长度不确定
	* 第三种定义格式
		* `int[][] arr = { {1,2},{3,4,5,6},{7,8,9}};`
		* 二维数组中定义了三个元素，这三个元素都是数组，分别为`{1,2}`、`{3,4,5,6}`、`{7,8,9}`

### 14 二维数组元素的访问
```java
class ArrayDemo08 {
	public static void main(String[] args){

		//定义二维数组的方式
		int[][] arr = new int[3][4];
		System.out.println( arr );
		System.out.println("二维数组的长度: " + arr.length);
		//获取二维数组的3个元素
		System.out.println( arr[0] );
		System.out.println( arr[1] );
		System.out.println( arr[2] );
		
		System.out.println("打印第一个一维数组的元素值");
		System.out.println( arr[0][0] );
		System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素
		System.out.println( arr[0][2] );
		System.out.println( arr[0][3] );
		
		System.out.println("打印第二个一维数组的元素值");
		System.out.println( arr[1][0] );
		System.out.println( arr[1][1] );
		System.out.println( arr[1][2] );
		System.out.println( arr[1][3] );
		
		System.out.println("打印第三个一维数组的元素值");
		System.out.println( arr[2][0] );
		System.out.println( arr[2][1] );
		System.out.println( arr[2][2] );
		System.out.println( arr[2][3] );
	}
}
```

### 15 二维数组内存图

- 举例:`int[][] arr = new int[3][2];`
- 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值
- 每一个大内存空间里又开辟连续的两个小的内存空间.
	
### 16 二维数组的遍历
- 二维数组遍历
	- `int[][] arr = { {1,2,4},{4,7},{0,9,3}};`
	- 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组
	- 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素

- 遍历打印
	```java
	public class ArrayArrayDemo_2{
		public static void main(String[] args){
			int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} };
			
			//外循环,遍历二维数组
			for(int i = 0 ; i < arr.length ;i++){
				//内循环,遍历每个一维数组 arr[0] arr[1] arr[i]
				for(int j = 0 ; j < arr[i].length; j++){
					System.out.print(arr[i][j]);
				}
				System.out.println();
			}
		}
	```
- 累加求和
	```java
	class ArrayDemo09 {
		public static void main(String[] args){
			int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };
			int sum2 = 0;
			for (int i=0; i<arr2.length; i++) {
				for (int j=0; j<arr2[i].length; j++) {
						//System.out.println(arr2[i][j])
					sum2 += arr2[i][j];
				}
			}
			System.out.println("sum2= "+ sum2);
		}
	}
	```

## day05


### 摘要
1. 方法基础知识
2. 方法高级内容
3. 方法案例


### 01 方法的概述
- 为什么要有方法
	* 提高代码的复用性 
- 什么是方法
	* 完成特定功能的代码块。 

### 02 方法的定义格式
- 方法的格式
	```txt
	修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
		方法体语句;
		return 返回值; 
	} 
	```
- 方法的格式说明
	* 修饰符：例如 public static。
	* 返回值类型：就是功能结果的数据类型。
	* 方法名：符合命名规则即可。方便我们的调用。
	* 参数：
		- 实际参数：就是实际参与运算的。
		- 形式参数；就是方法定义上的，用于接收实际参数的。
	* 参数类型：就是参数的数据类型
	* 参数名：就是变量名
	* 方法体语句：就是完成功能的代码。
	* return：结束方法的。
	* 返回值：就是功能的结果，由return带给调用者。

### 03 定义方法计算面积

```java
public class MethodDemo{

	public static void main(String[] args){
			//调用方法, 方法执行起来
			// 在方法main中,调用方法 getArea

			int area = getArea(5,6);
			System.out.println("面积是: "+area);
		
	}
	/*
		要求: 计算一个长方形的面积
		定义方法解决这个要求
		分析方法定义过程:
			1.明确方法计算后的结果的数据类型 int  定义格式对应的就是返回值类型
			2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int
				未知数的变量,定义在方法的小括号内
	*/
	public static int  getArea(int w, int h){
		//实现方法的功能主体
		//int area = w * h;
		return w * h;
	}
}
```

### 04 调用方法
* 调用方法
	* 在main函数中调用方法，让方法执行起来
	* 方法的形参
		* 方法要什么参数我们就给什么类型的参数。
	* 方法的返回值
		* 方法返回什么类型的值我们就用对应的数据类型的变量来接收


### 05 调用方法执行流程
* 调用方法执行流程
	* 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。
	* 方法的执行，是把实参传递给形参，从而来执行的。
	* 方法只有被调用才会执行。

### 06 方法的重载
- 方法的重载
	* 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。

	* 参数列表不同：
		- 参数个数不同
		- 参数类型不同
		- 参数的顺序不同(算重载,但是在开发中不用)

- 案例代码
	```java
	public static int getSum(int a,int b){
		System.out.println("两个int参数");
		return a+b;
	}
	public static int getSum(int a,int b,int c){
		System.out.println("三个int参数");
		return a+b+c;
	}
	public static double getSum(double a,double b){
		System.out.println("两个double参数");
		return a+b;
	}
	```
	
### 07 方法重载注意事项
- 参数列表必须不同
- 重载和参数变量名无关
- 重载和返回值类型无关
- 重载和修饰符无关
- 技巧: 重载看方法名和参数列表
		
### 08 传参
- 方法参数是基本数据类型，传递的是值。
- 方法参数是引用数据类型，传递的是内存地址值。

### 09 可变长参数列表
如果参数类型完全相同，但是个数不确定，可以用`type...variableName`的方式传入参数，这是实际传入的是一个数组`variableName`，但是调用时可以传入任意个数的指定类型参数。

**注意**

- 一个方法中只能有一个可变长参数
- 可变长参数必须放在参数列表的最后

## day06

### 摘要
1. 自定义类型的定义及使用
2. ArrayList集合的基本功能

### 01 引用数据类型_类
- 数据类型
	* java中的数据类型分为：`基本类型`和`引用类型`
- 引用类型的分类
	* Java为我们提供好的类，比如说：Scanner,Random等。
	* 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 

### 02 自定义类的概述
- java代码映射成现实事物的过程就是定义类的过程。
- 举例：我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性

### 03 自定义类的格式
- 使用类的形式,对现实中的事物进行描述。
- 事物由方法和属性两部分组成。
	* 方法: 这个事物具备的功能。
	* 属性: 这个事物具备的特征。
- 格式
	```txt
	public class 类名{
		属性定义
			修饰符 数据类型 变量名 = 值
		
		方法定义
			修饰符 返回值类型  方法名(参数列表){
				
			}
	}
	```

### 04 使用自定义类
- 调用方法执行流程
	* 导入包,类都是在同一个文件夹,不需要导入包
	* 创建引用类型的变量
	* 变量.类型中的功能

- 创建类实例时内存变化
	* 在堆内存中分配出对象存储空间
	* 初始化对象上的实例变量

### 05 ArrayList创建变量的步骤

- 导入包 java.util包中
- 创建引用类型的变量
	* `数据类型< 集合存储的数据类型>  变量名 = new 数据类型<集合存储的数据类型>()`;
	* 集合存储的数据类型: 要将数据存储到集合的容器中
	* 创建集合引用变量的时候,必须要指定好,存储的类型是什么
- 变量名.方法 
	* 注意: 集合存储的数据,8个基本类型对应8个引用类型
	* 存储引用类型,不存储基本类型

### 06 ArrayList的常见方法
- `add(参数)` 向集合中添加元素
- `get(int index)` 取出集合中的元素,get方法的参数,写入索引
- `size()` 返回集合的长度, 集合存储元素的个数

### 07 ArrayList集合的遍历
```java
/*
	集合的遍历
	实现思想也是索引思想
	集合的索引从0开始,到 size()-1
	方法get(int index)
*/
import java.util.ArrayList;
public class ArrayListDemo_2{
	public static void main(String[] args){
		ArrayList<Integer> array = new ArrayList<Integer>();
		array.add(121);
		array.add(125);
		array.add(123);
		array.add(120);
		array.add(128);
		
		//对集合进行遍历
		//使用方法 size+get组合进行遍历
		for(int i = 0 ; i < array.size(); i++){
			System.out.println( array.get(i) );
		}
	}
}
```

### 08 ArrayList补充方法
- `add(int 索引,存储的元素)` 将元素添加到指定的索引上
- `set(int 索引,修改后的元素)` 将指定索引的元素,进行修改
- `remove(int 索引)` 删除指定索引上的元素
- `clear()` 清空集合中的所有元素


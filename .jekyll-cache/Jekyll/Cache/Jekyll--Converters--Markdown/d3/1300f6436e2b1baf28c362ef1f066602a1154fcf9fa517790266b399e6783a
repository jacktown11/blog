I"A<h2 id="section">类与对象</h2>
<ul>
<li><strong>类</strong>: 用于描述多个对象的共同特征，它是对象的模板。</li>
<li><strong>对象</strong>: 用于描述现实中的个体，它是类的实例。</li>
<li>定义类<pre><code class="language-txt">>class 类名 {
    //属性
    数据类型 变量名;
    …
    //方法
    修饰符 返回值类型 方法名(参数){   }
    …
}
</code></pre></li>
<li>创建对象<pre><code class="language-txt">>类名 对象名 = new 类名();
</code></pre></li>
</ul>
<h2 id="section-1">封装</h2>
<p>把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式</p>
<h3 id="section-2">封装的体现</h3>
<ul>
<li>变量: 使用<code>private</code>修饰变量，然后提供<code>get</code>和<code>set</code>方法供外界访问，这就是变量的封装</li>
<li>方法: 也是一种封装，封装了多条代码</li>
<li>类: 也是一种封装，封装了多个方法(功能)</li>
</ul>
<h2 id="section-3">继承</h2>
<p><strong>继承</strong>是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作<code>子类</code>，现有类被称作<code>父类</code>，子类会自动拥有父类所有。</p>
<h3 id="section-4">好处</h3>
<ul>
<li>提高了代表的可维护性</li>
<li>提高了代码的复用性</li>
<li>让类与类之间产生了继承关系，为多态提供基础</li>
</ul>
<h3 id="section-5">弊端</h3>
<p>类与类之间的耦合度过高</p>
<h3 id="java">java中继承的特点</h3>
<ul>
<li>java中类只能够单继承，不能多继承，可以多层继承
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Yy</span> <span class="kd">extends</span> <span class="nc">Object</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Fu</span> <span class="kd">extends</span> <span class="nc">Yy</span><span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="nc">Fu</span> <span class="o">{}</span>
</code></pre></div></div>
</li>
<li>所有的类都直接或者间接的继承了<code>Object</code>类，Object类称为祖宗类。</li>
</ul>
<h3 id="section-6">注意事项</h3>
<ol>
<li>使用关键字<code>extends</code>让类与类之间产生继承关系</li>
<li>父类私有的成员，子类不能继承，因为根本看不到</li>
<li>不能为了继承某个功能而随意进行继承操作， 必须要符合<code>IS A</code>的关系<pre><code class="language-txt">>苹果 IS A 水果
男人 IS A 人
狗   IS A 人 , 这种情况就不能继承了
</code></pre></li>
</ol>
<h3 id="section-7">继承中的成员变量关系</h3>
<ul>
<li>不同名的变量： 子类直接继承使用</li>
<li>同名的变量： 默认访问的是子类自己的成员变量, 想访问父类中的同名变量，请使用<code>super.成员变量</code></li>
</ul>
<h3 id="section-8">继承中的成员方法关系：</h3>
<ul>
<li>不同名的方法： 子类直接继承使用</li>
<li>同名的方法： 默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用<code>super.成员方法()</code></li>
</ul>
<h3 id="override">方法覆盖/重写(override)</h3>
<p>指在子父类中，出现了方法声明相同的情况，也叫做<code>方法覆盖/方法重写</code>。</p>
<ul>
<li>注意事项
<ol>
<li>子类的方法声明要与父类相同</li>
<li>子类要重写方法的方法，方法的权限修饰符不能比父类的更低; 返回值类型是与父类中相同或是其子类</li>
<li>父类私有的方法，子类不能够进行方法重写</li>
</ol>
</li>
<li>对比
<ul>
<li><code>方法重载</code>(<code>overload</code>)：指在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)</li>
</ul>
</li>
</ul>
<h2 id="section-9">抽象</h2>
<h3 id="section-10">抽象方法</h3>
<p>方法只有声明部分，没有方法体</p>
<h3 id="section-11">抽象类</h3>
<ul>
<li>包含抽象方法的类，一定是抽象类</li>
<li>使用<code>abstract</code>修饰的类，是抽象类</li>
</ul>
<h3 id="section-12">抽象类的特点</h3>
<ul>
<li>抽象类与抽象方法都必须使用 abstract来修饰</li>
<li>抽象类不能直接创建对象</li>
<li>抽象类中可以有抽象方法，也可以没有抽象方法</li>
<li>抽象类的子类
<ul>
<li>全部实现了父类抽象方法的具体类</li>
<li>未实现或未完全实现父类抽象方法的抽象类</li>
</ul>
</li>
<li>没有抽象方法的抽象类的意义
<ul>
<li>可以通过这种方式禁止该类被实例化</li>
</ul>
</li>
</ul>
<h2 id="section-13">接口</h2>
<h3 id="section-14">概述</h3>
<p>理解为是一个特殊的抽象类，但它不是类，是一个接口</p>
<ul>
<li>定义一个接口用interface关键字,<code>interface Inter{}</code></li>
<li>一个类实现一个接口，使用implements关键字,<code>class Demo implements Inter{}</code></li>
<li>接口不能直接创建对象，通过多态的方式，由子类来创建对象(接口多态)</li>
</ul>
<h3 id="section-15">接口中的成员特点</h3>
<ul>
<li>成员变量
<ul>
<li>只能是<code>final</code>修饰的常量</li>
<li>默认修饰符： <code>public static final</code></li>
</ul>
</li>
<li>构造方法
<ul>
<li>无</li>
</ul>
</li>
<li>成员方法
<ul>
<li>只能是抽象方法</li>
<li>默认修饰符: <code>public abstract</code></li>
</ul>
</li>
</ul>
<h3 id="section-16">类与类，类与接口，接口与接口之间的关系</h3>
<ul>
<li>类与类之间：继承关系，单继承，可以是多层继承</li>
<li>类与接口之间: 实现关系，单实现，也可以多实现</li>
<li>接口与接口之间：继承关系，单继承，也可以是多继承</li>
<li>Java中的类可以继承一个父类的同时，实现多个接口</li>
</ul>
<h2 id="section-17">多态</h2>
<p>理解为同一种物质的多种形态</p>
<h3 id="section-18">使用的前提</h3>
<ul>
<li>有继承或者实现关系</li>
<li>要方法重写</li>
<li>父类引用指向子类对象</li>
</ul>
<h3 id="section-19">成员访问特点</h3>
<ul>
<li>编译期看引用类型是否有该成员</li>
<li>运行期成员属性必须是该引用类型成员，而方法则可能是被具体子类覆盖过的</li>
</ul>
<h3 id="section-20">好处</h3>
<p>提高了程序的扩展性</p>
<h3 id="section-21">弊端</h3>
<p>不能访问子类的特有功能</p>
<h3 id="section-22">多态的分类</h3>
<ul>
<li>(抽象)类的多态
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Fu</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="nc">Fu</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“</span><span class="n">重写父类抽象方法</span><span class="err">”</span><span class="o">);</span>
<span class="o">}</span>
<span class="o">}</span>
<span class="c1">//类的多态使用</span>
<span class="nc">Fu</span> <span class="n">fu</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Zi</span><span class="o">();</span>
</code></pre></div></div>
</li>
<li>接口的多态
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Fu</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">implements</span> <span class="nc">Fu</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“</span><span class="n">重写接口抽象方法</span><span class="err">”</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//接口的多态使用</span>
<span class="nc">Fu</span> <span class="n">fu</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Zi</span><span class="o">();</span>
</code></pre></div></div>
</li>
</ul>
<h2 id="section-23">构造方法</h2>
<p>用来给类的成员进行初始化操作</p>
<ul>
<li>格式<pre><code class="language-txt">>修饰符 类名 (参数列表) {
    ...
}
</code></pre></li>
<li>构造方法的特点
<ul>
<li>方法名与类名相同</li>
<li>没有返回值，也没有返回值类型，连void也没有</li>
</ul>
</li>
<li>构造方法什么时候会被调用执行？
<ul>
<li>只有在创建对象的时候才可以被调用</li>
</ul>
</li>
</ul>
<h3 id="section-24">构造方法注意事项</h3>
<ul>
<li>如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法；如果我们没写任何的构造方法，编译器提供给我们一个空参数构造方法</li>
<li>在构造方法中，默认的第一条语句为 super();它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作</li>
<li>当父类中没有空参数构造方法的时候，怎么办？
<ul>
<li>通过<code>super(参数)</code>访问父类有参数的构造方法</li>
<li>通过<code>this(参数)</code>访问本类中其他构造方法[该方法已经能够正常访问父类构造方法]</li>
</ul>
</li>
<li><code>super(参数)</code>与<code>this(参数)</code>不能同时在构造方法中存在</li>
</ul>
<h2 id="section-25">相关关键字</h2>
<h3 id="super">super</h3>
<p>指的是父类的存储空间(理解为父类的引用),提供了在子类中访问父类成员与构造器的手段。</p>
<ul>
<li>调用父类的成员变量： <code>super.成员变量</code>;</li>
<li>调用父类的构造方法： <code>super(参数)</code>;</li>
<li>调用父类的成员方法： <code>super.成员方法()</code>;</li>
</ul>
<h3 id="this">this</h3>
<ul>
<li>本类对象的引用</li>
<li>this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用</li>
<li>this什么时候存在的？当创建对象的时候，this存在的</li>
<li>this的作用：用来区别同名的成员变量与局部变量（this.成员变量）
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>
</li>
</ul>
<h3 id="instanceof">instanceof</h3>
<ul>
<li>格式： <code>对象名 instanceof 类名</code></li>
<li>返回值： <code>true</code>/<code>false</code></li>
<li>作用： 判断指定的对象是否为给定类(接口)创建的对象</li>
</ul>
<h2 id="section-26">修饰符</h2>
<h3 id="public">public</h3>
<h3 id="protected">protected</h3>
<h3 id="default"><default>(默认的权限)</h3>
<h3 id="private">private</h3>
<ul>
<li>私有的意思,它可以用来修饰类中的成员(成员变量，成员方法)</li>
<li>特点：private修饰的成员只能在当前类中访问，其他类中无法直接访问</li>
</ul>
<h3 id="final">final</h3>
<ul>
<li>final修饰的类： 最终的类，不能被继承</li>
<li>final修饰的变量： 相当于是一个常量, 在编译生产.class文件后，该变量变为常量值</li>
<li>final修饰的方法： 最终的方法，子类不能重写，可以继承过来使用</li>
</ul>
<h3 id="static">static</h3>
<p>静态，可以用来修饰类中的成员(成员变量，成员方法)</p>
<ul>
<li>注意： 也可以用来修饰成员内部类</li>
<li>特点：
<ul>
<li>被静态所修饰的成员，会被所有的对象所共享</li>
<li>被静态所修饰的成员，可以通过类名直接调用，方便</li>
</ul>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span><span class="o">.</span><span class="na">country</span> <span class="o">=</span> <span class="s">"中国"</span><span class="o">;</span>
<span class="nc">Person</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
</code></pre></div></div>
</li>
<li>注意事项：
<ul>
<li>静态的成员，随着类的加载而加载，优先于对象存在</li>
<li>在静态方法中，没有this关键字</li>
<li>静态方法中，只能调用静态的成员(静态成员变量，静态成员方法)</li>
</ul>
</li>
</ul>
<h3 id="abstract">abstract</h3>
<h3 id="section-27">权限修饰符小结</h3>
<p>权限修饰符对各位置中访问性的限制</p>
<p>|位置\修饰符 |public  |protected|	默认的|	private|
|-----|:------:|:------:|:-----:|:-------:|
|在当前类中|Y|Y|Y|Y|
|同一包中的其他类|Y|Y|Y||
|不同包中的子类|Y|Y|||
|不同包中的其他类|Y||||</p>
<h3 id="section-28">各种字段可能使用的修饰符</h3>
<p>|修饰符\字段|类|成员变量|成员方法|构造方法|局部变量|
|:----:|:----:|:----:|:----:|:----:|:----:|
|public|    Y | Y | Y | Y |   |
|protected|   | Y | Y | Y |   |
|默认|      Y | Y | Y | Y |   |
|private|     | Y | Y | Y |   |
|final|     Y | Y | Y |   | Y |
|static|      | Y | Y |   |   |
|abstract|  Y |   | Y |   |   |</p>
<p>有的修饰符不可能同时使用，比如<code>abstract</code>与<code>private</code>、<code>static</code>、<code>final</code>不会同时出现。</p>
<h2 id="section-29">内部类</h2>
<p>在一个类中，定义了一个新类，这个新的类就是内部类</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span><span class="c1">//外部类</span>
    <span class="kd">class</span> <span class="nc">B</span><span class="o">{</span><span class="c1">// 内部类</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="section-30">特点</h3>
<p>内部类可以直接访问外部类的成员，包含私有的成员</p>
<h3 id="section-31">匿名内部类</h3>
<p>举例</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">OneInterface</span><span class="o">(){</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">implementedMethod</span><span class="o">(){</span>
        <span class="c1">// implemention</span>
    <span class="o">}</span>
<span class="o">}.</span><span class="na">implementedMethod</span><span class="o">();</span>
</code></pre></div></div>
<h2 id="section-32">包</h2>
<h3 id="section-33">声明</h3>
<p><code>package 包名.包名.包名…;</code></p>
<h3 id="section-34">带包名对象的创建</h3>
<p><code>包名.类名 变量名 = new包名.类名();</code></p>
<h3 id="section-35">导包</h3>
<p><code>import 包名.类名;</code></p>
<h2 id="section-36">代码块</h2>
<ul>
<li>局部代码块：定义在方法中的，用来限制变量的作用范围</li>
<li>构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值</li>
<li>静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值</li>
<li>运行顺序：静态代码块最早， 构造代码块在对象创建过程中运行，早于构造方法。</li>
</ul>
:ET